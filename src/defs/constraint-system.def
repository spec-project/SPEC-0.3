%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SPEC                                                                     
% Copyright (C) 2011-2017 Alwen Tiu, Ross Horne, Nam Nguyen
%
% This program is free software; you can redistribute it and/or modify     
% it under the terms of the GNU General Public License as published by     
% the Free Software Foundation; either version 2 of the License, or        
% (at your option) any later version.                                      
%
% This program is distributed in the hope that it will be useful,          
% but WITHOUT ANY WARRANTY; without even the implied warranty of           
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
% GNU General Public License for more details.                             
%
% You should have received a copy of the GNU General Public License        
% along with this code; if not, write to the Free Software Foundation,     
% Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA             
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#include "intruder.def".

% Define membership constraints
Type mbsc tm -> list tm -> tm -> constraint.
Type dedc list tm -> tm -> constraint.

Define print_cs : constraint -> prop
by  
print_cs (dedc S M) := plist S /\ printstr " |- " /\ print_term M ;
print_cs (mbsc V T U) := print_term V /\ printstr " Bd({" /\ plist T /\ printstr "} , " /\ print_term U /\ printstr ")" .
 
Define plist_csl : list constraint -> prop
by
plist_csl nil ;
plist_csl (cons X nil) := print_cs X ; 
plist_csl (cons X (cons Y L)) :=
  print_cs X /\
  printstr " ; \n" /\
  plist_csl (cons Y L).

Define cs_print_list_cst : list constraint -> prop
by
cs_print_list_cst L :=
  printstr"[" /\ plist_csl L /\ printstr "]\n".

Define cs_apply : list sub_pair -> constraint -> constraint -> prop by 
cs_apply Subst (dedc T1 U1) (dedc T2 U2) :=
  copylist Subst T1 T2 /\ copyterm Subst U1 U2 ;
cs_apply Subst (mbsc U1 T1 V1) (mbsc U2 T2 V2) := 
  copyterm Subst U1 U2 /\ copylist Subst T1 T2 /\ copyterm Subst V1 V2 .

Define cs_apply_list : list sub_pair -> list constraint -> list constraint -> prop by 
cs_apply_list Subst nil nil ; 
cs_apply_list Subst (cons C L) (cons D R) :=
  cs_apply Subst C D /\ cs_apply_list Subst L R.

% Get variable list in term list
Define get_var_list_tm : list tm -> list tm -> list tm -> prop by
get_var_list_tm nil VarIn VarIn;
get_var_list_tm (cons T L) VarIn VarOut :=
  get_var T VarIn Vs /\
  get_var_list_tm L Vs VarOut.

% Get Tx
Define get_T_var : list constraint -> tm -> list tm -> list tm -> prop by
get_T_var nil Var TIn TOut ;
get_T_var (cons Cs CsL) Var TIn TOut :=
  (Cs = dedc T U \/ Cs = mbsc V T U) /\
  _if (get_var_list_tm T nil TVars /\ _not(det_mem Vars TVars) /\ get_var U nil UVars /\ det_mem Var UVars)
    (
      _if (TIn = nil \/ subset T TIn) (get_T_var CsL Var T TOut) (get_T_var CsL Var TIn TOut)
    )
    (get_T_var CsL Var TVarIn TVarOut).

% Check if a term is subterm of another term
Define sub_term : tm -> tm -> prop by
sub_term (ct X) (ct X) ;
sub_term (nm X) (nm X) ;
sub_term (var X) (var X) ;
sub_term T (pr X Y) := T = pr X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (en X Y) := T = en X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (aen X Y) := T = aen X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (pub X) := T = pub X \/ sub_term T X ;
sub_term T (blind X Y) := T = blind X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (sign X Y) := T = sign X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (hs X) := T = hs X \/ sub_term T X ;
sub_term T (mac X Y) := T = mac X Y \/ sub_term T X \/ sub_term T Y .

% Check if a term is subterm in a list of term
Define sub_term_list : tm -> list tm -> prop by
sub_term_list S (cons T L) := sub_term S T \/ sub_term_list S L.

% Simplication rules for membership constraints
% Note: In a set of constraints in simplified form, each membership constraint is of the form mbsc (var X) T U
Define simplication_rule : list constraint -> list constraint -> list constraint -> list sub_pair -> list sub_pair -> list tm ->
prop by
simplication_rule CsIn nil CsIn SubstIn SubstIn Vs ;

% Sax
simplication_rule Processed (cons (mbsc V T U) CsL) CsOut SubstIn SubstOut Vs :=
  _not (V = U \/ V = blind M N \/ V = pr M N) /\
  _if (_cut(select CsL (mbsc V T U) CsLI))
    (simplication_rule Processed CsL CsOut SubstIn SubstOut Vs)
    (
      simplication_rule (cons (mbsc V T U) Processed) CsL CsOut SubstIn SubstOut Vs
    ) ;
simplication_rule Processed (cons (mbsc U T U) CsL) CsOut SubstIn SubstOut Vs :=
  simplication_rule Processed CsL CsOut SubstIn SubstOut Vs;

% Sbd
simplication_rule Processed (cons (mbsc (blind U V) T W) CsL) CsOut SubstIn SubstOut Vs :=
  _not (W = blind U V) /\
  append Processed (cons (dedc T V) (cons (mbsc U T W) CsL)) CsIn /\
  simplication_rule nil CsIn CsOut SubstIn SubstOut Vs;

% Sbd - Unify
%simplication_rule Processed (cons (mbsc (blind U V) T W) CsL) CsOut SubstIn SubstOut Vs :=
%  _not (W = blind U V) /\
%  unify nil (blind U V) W Vs Subst /\
%  compose Vs SubstIn Subst SubstInI /\
%  append Processed CsL CsLI /\
%  cs_apply_list Subst CsLI Ds /\
%  simplication_rule nil Ds CsOut SubstInI SubstOut Vs ;
% Sbd - Unify
simplication_rule Processed (cons (mbsc U T W) CsL) CsOut SubstIn SubstOut Vs :=
  _not (W = U \/ U = var X) /\
  unify nil U W Vs Subst /\
  compose Vs SubstIn Subst SubstInI /\
  append Processed CsL CsLI /\
  cs_apply_list Subst CsLI Ds /\
  simplication_rule nil Ds CsOut SubstInI SubstOut Vs ;
% Sleft
simplication_rule Processed (cons (mbsc (pr U V) T W) CsL) CsOut SubstIn SubstOut Vs :=
  _not (pr U V = W) /\
  append Processed (cons (mbsc U T W) CsL) CsIn /\
  simplication_rule nil CsIn CsOut SubstIn SubstOut Vs;
% Sright
simplication_rule Processed (cons (mbsc (pr U V) T W) CsL) CsOut SubstIn SubstOut Vs :=
  _not (pr U V = W) /\
  append Processed (cons (mbsc V T W) CsL) CsIn /\
  simplication_rule nil CsIn CsOut SubstIn SubstOut Vs;
% Rax
simplication_rule Processed (cons (dedc T U) CsL) CsOut SubstIn SubstOut Vs :=
  (det_mem U T \/ U = ct M) /\ simplication_rule Processed CsL CsOut SubstIn SubstOut Vs;
% Rtriv
simplication_rule Processed (cons (dedc T U) CsL) CsOut SubstIn SubstOut Vs :=
  _not (det_mem U T) /\ _not(U = ct M) /\
  append Processed CsL CsIn /\
  _if (_cut(select CsIn (dedc T' U) CsLI))
    (
      _if (subset T T')
	(
	  simplication_rule (cons (dedc T U) nil) CsLI CsOut SubstIn SubstOut Vs
	)
	(
	  simplication_rule Processed CsL CsOut SubstIn SubstOut Vs
	)
    )
    (
      simplication_rule (cons (dedc T U) Processed) CsL CsOut SubstIn SubstOut Vs
    ).
% Sf is not necessary to check
% Scycle is not necessary to check because of transformation_rule_loop_mbsc

% Solved Form
Define cs_solved_form : list constraint -> prop by
%cs_solved_form CsL :=
%  forall Cs, member Cs CsL -> (
%    exists T, exists X, (
%      Cs = dedc T (var X) \/
%      (
%	exists U, Cs = mbsc (var X) T U /\ member (dedc T (var X)) CsL /\
%	_not (
%	  exists TI, exists UI, member (mbsc (var X) TI UI) CsL /\ _not(TI = T /\ UI = U)
%	)
%      )
%    )
%  )
%.
% Using forall will cause Bedwyr error: Prover.Level_inconsistency
cs_solved_form nil ;
cs_solved_form CsL :=
  _not (
    member (dedc T U) CsL /\
    _not (U = var X)
  ) /\
  _not (
    select CsL (mbsc V T U) CsLI /\
    (
      _not (V = var X) \/
      _not (member (dedc T V) CsLI) \/
      member (mbsc V T' U') CsLI
    )
  ).

Define transformation_rule_loop_dedc : constraint -> list constraint -> list constraint -> list constraint -> list constraint -> prop by
% Rf
transformation_rule_loop_dedc (dedc T M) CsL Ds LoopIn LoopOut :=
  (M = blind U V \/ M = sign U V \/ M = pr U V \/ M = en U V \/ M = aen U V) /\
  _not(det_mem (dedc T M) LoopIn) /\
  LoopOut = cons (dedc T M) LoopIn /\
  Ds = cons (dedc T U) (cons (dedc T V) CsL)
  %/\ printstr "\nT3 " /\ cs_print_list_cst (cons (dedc T M) CsL) /\ cs_print_list_cst Ds
;
% Rf
transformation_rule_loop_dedc (dedc T (pub V)) CsL Ds LoopIn LoopOut :=
  _not (det_mem (dedc T (pub V)) LoopIn) /\
  LoopOut = cons (dedc T (pub V)) LoopIn /\
  Ds = cons (dedc T V) CsL
  %/\ printstr " T3 Pub " /\ cs_print_list_cst (cons (dedc T (pub V)) CsL) /\ cs_print_list_cst Ds
;
% Rf
transformation_rule_loop_dedc (dedc T (hs V)) CsL Ds LoopIn LoopOut :=
  _not (det_mem (dedc T (hs V)) LoopIn) /\
  LoopOut = cons (dedc T (hs V)) LoopIn /\
  Ds = cons (dedc T V) CsL
  %/\ printstr " T3 Hash " /\ cs_print_list_cst (cons (dedc T (hs V)) CsL) /\ cs_print_list_cst Ds
;
% Rbd
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (blind V U) T) /\
  Ds = cons (dedc T (blind V U)) (cons (dedc T U) CsL)
  %/\ printstr "\nT4 Blind " /\ cs_print_list_cst (cons (dedc T V) CsL) /\ cs_print_list_cst Ds
;
% Rget
%transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
%  _distinct(sub_term_list (sign V U) T) /\
%  _not(det_mem (dedc T (sign V U)) LoopIn) /\
%  LoopOut = cons (dedc T (sign V U)) LoopIn /\
%  Ds = cons (dedc T (sign V U)) CsL
%  %/\ printstr " T5 Sign "
%;
% Rpair
transformation_rule_loop_dedc (dedc T U) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (pr M N) T) /\ (U = M \/ U = N) /\
  _not(det_mem (dedc T (pr M N)) LoopIn) /\
  LoopOut = cons (dedc T (pr M N)) LoopIn /\
  Ds = cons (dedc T (pr M N)) CsL
  %/\ printstr " T10 Pair " %/\ cs_print_list_cst Ds
;
% Rdec
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (en V U) T) /\
  _not(det_mem (dedc T (en V U)) LoopIn) /\
  LoopOut = cons (dedc T (en V U)) LoopIn /\
  Ds = cons (dedc T (en V U)) (cons (dedc T U) CsL)
  %/\ printstr " T11 Enc "
;
% Radec
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (aen V (pub U)) T) /\
  _not(det_mem (dedc T (aen V (pub U))) LoopIn) /\
  LoopOut = cons (dedc T (aen V (pub U))) LoopIn /\
  Ds = cons (dedc T (aen V (pub U))) (cons (dedc T U) CsL)
  %/\ printstr " T12 Aen " %/\ cs_print_list_cst Ds
.

Define transformation_rule_loop_mbsc : constraint -> list constraint -> list constraint -> list constraint -> list constraint -> prop by
% Rbdsgn
% In the rules Rbdsgn and Ra, Rb, Rc, pushing membership constraints before deducibility constraints might help to reduce running time
transformation_rule_loop_mbsc (dedc T (sign V U)) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (sign W U) T) /\ _not(V = W \/ det_mem (dedc T (sign W U)) LoopIn) /\
  LoopOut = cons (dedc T (sign W U)) LoopIn /\
  Ds = cons (dedc T (sign W U)) (cons (mbsc W T V) CsL)
  %/\ printstr "\nT6 Bdsgn " /\ cs_print_list_cst (cons (dedc T (sign V U)) CsL) /\ cs_print_list_cst Ds
.

Define transformation_rule : nat -> list constraint -> list constraint -> prop by
% Ra
% Checking V = var X is not necessary because of simplication_rule already removed this case
transformation_rule 7 Cs Ds :=
  select Cs (mbsc (var X) T' V) CsI /\ select CsI (dedc T (var X)) CsII /\
  _not(T = T') /\ subset T T' /\
  Ds = cons (dedc T V) (cons (mbsc (var X) T V) CsI)
  %/\ printstr "\nT7 Ra " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
;
% Rb
transformation_rule 8 Cs Ds :=
  select Cs (mbsc (var X) T' V) CsI /\ select CsI (dedc T (var X)) CsII /\
  _not(T = T') /\ subset T T' /\ _distinct(sub_term_list W T) /\
  Ds = cons (dedc T W) (cons (mbsc (var X) T W) (cons (mbsc W T' V) CsI))
  %/\ printstr "\nT8 Rb " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
;
% Rc
% 1. Checking V = V' is not necessary because of simplication_rule already removed two similar membership constraint
transformation_rule 9 Cs Ds :=
  select Cs (mbsc (var X) T V') CsI /\ select CsI (mbsc (var X) T V) CsII /\ select CsII (dedc T (var X)) CsIII /\
  get_T_var Cs (var X) nil TVar /\ subset T TVar /\
  Ds = cons (mbsc V T V') CsI
  %/\ printstr "\nT9 Rc " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
.

Define unify_constraint : list tm -> list constraint -> constraint -> list constraint -> list constraint -> list sub_pair -> list sub_pair -> prop
by
unify_constraint Vs Pre (dedc T U) Post Ds SubstIn SubstOut :=
  unify_list Vs T U Subst /\
  compose Vs SubstIn Subst SubstOut /\
  append Pre Post CsL /\
  cs_apply_list Subst CsL Ds
  %/\ printstr "\nUnify " /\ append Pre (cons (dedc T U) Post) CsLI /\ cs_print_list_cst CsLI /\ cs_print_list_cst Ds
;
unify_constraint Vs Pre (dedc T V) Post Ds SubstIn SubstOut :=
  _cut(sub_term_list (aen V (var X)) T) /\
  Subst = (cons (sub (var X) (pub (var X))) nil) /\
  compose Vs SubstIn Subst SubstOut /\
  append Pre (cons (dedc T V) Post) CsL /\
  cs_apply_list Subst CsL Ds
  %/\ printstr "\nUnify Pub " /\ append Pre (cons (dedc T V) Post) CsLI /\ cs_print_list_cst CsLI /\ cs_print_list_cst Ds
.

Define separate : list constraint -> list constraint -> list constraint -> prop by
separate nil nil nil ;
separate (cons Cs CsL) Pre Post :=
  separate CsL NewPre NewPost /\
  _if (Cs = dedc T (var X) \/ Cs = mbsc V T U)
    (Pre = cons Cs NewPre /\ Post = NewPost)
    (Pre = NewPre /\ Post = cons Cs NewPost).

% Note: 09/02/2017: Pre is redundant - Need to remove
% Remove in both unify function
% Simplication rules and Transformation rule do not change T
Define cs_solve : list tm -> list constraint -> list constraint -> list sub_pair -> list sub_pair -> list constraint -> list constraint -> prop by
cs_solve Vs Pre Post SubstInX SubstOut LoopDedcIn LoopMbscIn :=
  append Pre Post PreCsL /\
  %printstr "\nBefore Simplification: " /\ cs_print_list_cst PreCsL /\
  simplication_rule nil PreCsL CsL SubstInX SubstIn Vs /\
  %printstr "\nAfter Simplification: " /\ cs_print_list_cst CsL /\
  _if (cs_solved_form CsL) (SubstOut = SubstIn)
    (
      separate CsL PreI NewPost /\
      _if (NewPost = nil) (transformation_rule TR CsL Ds /\ cs_solve Vs nil Ds SubstIn SubstOut LoopDedcIn LoopMbscIn)
      (
	NewPost = cons Cs PostII /\
	(
	  (unify_constraint Vs PreI Cs PostII Ds SubstIn NewSubst /\ NewPre = nil /\ LoopDedcOut = LoopDedcIn /\ LoopMbscOut = LoopMbscIn) \/
	  (transformation_rule_loop_dedc Cs PostII Ds LoopDedcIn LoopDedcOut /\ NewSubst = SubstIn /\ LoopMbscOut = LoopMbscIn /\ NewPre = PreI) \/
	  (transformation_rule_loop_mbsc Cs PostII Ds LoopMbscIn LoopMbscOut /\ NewSubst = SubstIn /\ LoopDedcOut = LoopDedcIn /\ NewPre = PreI)
	) /\
	cs_solve Vs NewPre Ds NewSubst SubstOut LoopDedcOut LoopMbscOut
      )
    ) .

% Decompose pair in constraint system
% The initial constraint system does not contain membership constraint
% Pair decomposing is not necessary 
Define cs_decompose_pair : list constraint -> list constraint -> prop by
cs_decompose_pair nil nil ;
cs_decompose_pair (cons (dedc T U) CsLIn) (cons (dedc T' U) CsLOut) := decpr T T' /\ cs_decompose_pair CsLIn CsLOut .

% Remove redundant constraints
% The initial constraint system does not contain membership constraint
Define cs_trim_cst : list constraint -> list tm -> list constraint -> prop by 
cs_trim_cst nil Rhs nil ;
cs_trim_cst (cons (dedc T U) L) Rhs Ds :=
  _if (U = ct X)
    (cs_trim_cst L Rhs Ds)
    (
      _if (det_mem U Rhs)
      (cs_trim_cst L Rhs Ds)
      (cs_trim_cst L (cons U Rhs) Cs /\ Ds = (cons (dedc T U) Cs))
    ) .

Define cs_solve_constraints : list tm -> list constraint -> list sub_pair -> prop
by
cs_solve_constraints Vs CsL Subst :=
  % This step might be redundant because of simplication_rule
  % cs_trim_cst CsL nil CsLI /\
  id_subst Vs IdSubst /\
  cs_solve Vs nil CsL IdSubst Subst nil nil
.

Define cs_get_var_cst : constraint -> list tm -> list tm -> prop by 
cs_get_var_cst (dedc T U) VarIn VarOut := get_var U VarIn VarOut ; 
cs_get_var_cst (mbsc V T U) VarIn VarOut := get_var U VarIn VarOut.

Define cs_get_var_csts : list constraint -> list tm -> list tm -> prop by 
cs_get_var_csts nil VarIn VarIn ; 
cs_get_var_csts (cons C L) VarIn VarOut :=
  cs_get_var_cst C VarIn Vs /\ 
  cs_get_var_csts L Vs VarOut.

Define cs_constraints_vars : list constraint -> list tm -> prop by 
cs_constraints_vars Cs Vars :=
  cs_get_var_csts Cs nil Vs /\ reverse Vs Vars.
