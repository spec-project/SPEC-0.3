%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SPEC                                                                     
% Copyright (C) 2011-2016 Alwen Tiu, Ross Horne, Nam Nguyen
%
% This program is free software; you can redistribute it and/or modify     
% it under the terms of the GNU General Public License as published by     
% the Free Software Foundation; either version 2 of the License, or        
% (at your option) any later version.                                      
%
% This program is distributed in the hope that it will be useful,          
% but WITHOUT ANY WARRANTY; without even the implied warranty of           
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
% GNU General Public License for more details.                             
%
% You should have received a copy of the GNU General Public License        
% along with this code; if not, write to the Free Software Foundation,     
% Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA             
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#include "intruder.def".

% Define membership constraints
Type mbsc tm -> list tm -> tm -> constraint.
Type dedc list tm -> tm -> constraint.

Define print_cs : constraint -> prop
by  
print_cs (dedc S M) := plist S /\ printstr " |- " /\ print_term M ;
print_cs (mbsc V T U) := print_term V /\ printstr " ({" /\ plist T /\ printstr "} , " /\ print_term U /\ printstr ")" .
 
Define plist_csl : list constraint -> prop
by
plist_csl nil ;
plist_csl (cons X nil) := print_cs X ; 
plist_csl (cons X (cons Y L)) :=
  print_cs X /\
  printstr " ; \n" /\
  plist_csl (cons Y L).

Define cs_print_list_cst : list constraint -> prop
by
cs_print_list_cst L :=
  printstr"[" /\ plist_csl L /\ printstr "]\n".

% Get variable list in term list
Define get_var_list_tm : list tm -> list tm -> list tm -> prop by
get_var_list_tm nil VarIn VarIn;
get_var_list_tm (cons T L) VarIn VarOut :=
  get_var T VarIn Vs /\
  get_var_list_tm L Vs VarOut.

% Get Tx
Define get_T_var : list constraint -> tm -> list tm -> list tm -> prop by
get_T_var nil Var TIn TOut ;
get_T_var (cons Cs CsL) Var TIn TOut :=
  (Cs = dedc T U \/ Cs = mbsc V T U) /\
  _if (get_var_list_tm T nil TVars /\ _not(det_mem Vars TVars) /\ get_var U nil UVars /\ det_mem Var UVars)
    (
      _if (TIn = nil \/ subset T TIn) (get_T_var CsL Var T TOut) (get_T_var CsL Var TIn TOut)
    )
    (get_T_var CsL Var TVarIn TVarOut).

% Check if a term is subterm of another term
Define sub_term : tm -> tm -> prop by
sub_term (nm X) (nm X) ;
sub_term (var X) (var X) ;
sub_term T (pr X Y) := T = pr X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (en X Y) := T = en X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (aen X Y) := T = aen X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (pub X) := T = pub X \/ sub_term T X ;
sub_term T (blind X Y) := T = blind X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (sign X Y) := T = sign X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (hs X) := T = hs X \/ sub_term T X ;
sub_term T (mac X Y) := T = mac X Y \/ sub_term T X \/ sub_term T Y .

% Check if a term is subterm in a list of term
Define sub_term_list : tm -> list tm -> prop by
sub_term_list S (cons T L) := sub_term S T \/ sub_term_list S L.

% Simplication rules for membership constraints
% Note: In a set of constraints in simplified form, each membership constraint is of the form mbsc (var X) T U
Define simplication_rule : list constraint -> list constraint -> prop by
simplication_rule nil nil;
% Sax
simplication_rule (cons (mbsc V T U) CsL) CsOut :=
  _not (V = U \/ V = blind M N \/ V = pr M N) /\
  _if (_cut(select CsL (mbsc V T U) CsLI)) (simplication_rule CsL CsOut)
    (simplication_rule CsL CsOutI /\ CsOut = cons (mbsc V T U) CsOutI);
simplication_rule (cons (mbsc U T U) CsL) CsOut :=
  simplication_rule CsL CsOut ;
% Sbd
simplication_rule (cons (mbsc (blind U V) T W) CsL) CsOut :=
  _not (W = blind U V) /\
  simplication_rule (cons (dedc T V) (cons (mbsc U T W) CsL)) CsOut ;
% Sleft
simplication_rule (cons (mbsc (pr U V) T W) CsL) CsOut :=
  _not (pr U V = W) /\
  simplication_rule (cons (mbsc U T W) CsL) CsOut ;
% Sright
simplication_rule (cons (mbsc (pr U V) T W) CsL) CsOut :=
  _not (pr U V = W) /\
  simplication_rule (cons (mbsc V T W) CsL) CsOut ;
% Rax
simplication_rule (cons (dedc T U) CsL) CsOut :=
  (det_mem U T \/ U = ct M)/\ simplication_rule CsL CsOut ;
% Rtriv
simplication_rule (cons (dedc T U) CsL) CsOut :=
  _not (det_mem U T) /\ _not(U = ct M) /\
  _if (_cut(select CsL (dedc T' U) CsLI))
    (
      _if (subset T T') (simplication_rule (cons (dedc T U) CsLI) CsOut)
	(simplication_rule CsL CsOut)
    )
    (simplication_rule CsL CsOutI /\ CsOut = cons (dedc T U) CsOutI) .
% Sf is not necessary to check
% Scycle is not necessary to check because of transformation_rule_loop_mbsc

% Solved Form
%Define cs_solved_form : list constraint -> prop by
%cs_solved_form CsL :=
%  forall Cs, member Cs CsL -> (
%    exists T, exists X, (
%      Cs = dedc T (var X) \/
%      (
%	exists U, Cs = mbsc (var X) T U /\ member (dedc T (var X)) CsL /\
%	_not (
%	  exists TI, exists UI, member (mbsc (var X) TI UI) CsL /\ _not(TI = T /\ UI = U)
%	)
%      )
%    )
%  )
%.
% Using forall will cause Bedwyr error: Prover.Level_inconsistency
Define cs_solved_form : list constraint -> prop by
cs_solved_form nil ;
cs_solved_form CsL :=
  _not (
    member (dedc T U) CsL /\
    _not (U = var X)
  ) /\
  _not (
    select CsL (mbsc V T U) CsLI /\
    (
      _not (V = var X) \/
      _not (member (dedc T V) CsL) \/
      member (mbsc V T' U') CsLI
    )
  ).

Define transformation_rule_loop_dedc : constraint -> list constraint -> list constraint -> list constraint -> list constraint -> prop by
% Rf
transformation_rule_loop_dedc (dedc T M) CsL Ds LoopIn LoopOut :=
  (M = blind U V \/ M = sign U V \/ M = pr U V \/ M = en U V \/ M = aen U V) /\
  _not(det_mem (dedc T M) LoopIn) /\
  LoopOut = cons (dedc T M) LoopIn /\
  Ds = cons (dedc T U) (cons (dedc T V) CsL)
  %/\ printstr "\nT3 " /\ cs_print_list_cst (cons (dedc T M) CsL) /\ cs_print_list_cst Ds
;
% Rf
transformation_rule_loop_dedc (dedc T (pub V)) CsL Ds LoopIn LoopOut :=
  _not (det_mem (dedc T (pub V)) LoopIn) /\
  LoopOut = cons (dedc T (pub V)) LoopIn /\
  Ds = cons (dedc T V) CsL
  %/\ printstr " T3 Pub " /\ cs_print_list_cst (cons (dedc T (pub V)) CsL) /\ cs_print_list_cst Ds
;
% Rbd
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  sub_term_list (blind V U) T /\
  Ds = cons (dedc T (blind V U)) (cons (dedc T U) CsL)
  %/\ printstr "\nT4 Blind " /\ cs_print_list_cst (cons (dedc T V) CsL) /\ cs_print_list_cst Ds
;
% Rget
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  sub_term_list (sign V U) T /\
  _not(det_mem (dedc T (sign V U)) LoopIn) /\
  LoopOut = cons (dedc T (sign V U)) LoopIn /\
  Ds = cons (dedc T (sign V U)) CsL
  %/\ printstr " T5 Sign "
;
% Rpair
transformation_rule_loop_dedc (dedc T U) CsL Ds LoopIn LoopOut :=
  sub_term_list (pr M N) T /\ (U = M \/ U = N) /\
  _not(det_mem (dedc T (pr M N)) LoopIn) /\
  LoopOut = cons (dedc T (pr M N)) LoopIn /\
  Ds = cons (dedc T (pr M N)) CsL
  %/\ printstr " T10 Pair " %/\ cs_print_list_cst Ds
;
% Rdec
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  sub_term_list (en V U) T /\
  _not(det_mem (dedc T (en V U)) LoopIn) /\
  LoopOut = cons (dedc T (en V U)) LoopIn /\
  Ds = cons (dedc T (en V U)) (cons (dedc T U) CsL)
  %/\ printstr " T11 Enc "
;
% Radec
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  sub_term_list (aen V (pub U)) T /\
  _not(det_mem (dedc T (aen V (pub U))) LoopIn) /\
  LoopOut = cons (dedc T (aen V (pub U))) LoopIn /\
  Ds = cons (dedc T (aen V (pub U))) (cons (dedc T U) CsL)
  %/\ printstr " T12 Aen " %/\ cs_print_list_cst Ds
.

Define transformation_rule_loop_mbsc : constraint -> list constraint -> list constraint -> list constraint -> list constraint -> prop by
% Rbdsgn
% In the rules Rbdsgn and Ra, Rb, Rc, pushing membership constraints before deducibility constraints might help to reduce running time
transformation_rule_loop_mbsc (dedc T (sign V U)) CsL Ds LoopIn LoopOut :=
  sub_term_list (sign W U) T /\ _not(V = W \/ det_mem (dedc T (sign W U)) LoopIn) /\
  LoopOut = cons (dedc T (sign W U)) LoopIn /\
  Ds = cons (dedc T (sign W U)) (cons (mbsc W T V) CsL)
  %/\ printstr "\nT6 Bdsgn " /\ cs_print_list_cst (cons (dedc T (sign V U)) CsL) /\ cs_print_list_cst Ds
.

Define transformation_rule : nat -> list constraint -> list constraint -> prop by
% Ra
% Checking V = var X is not necessary because of simplication_rule already removed this case
transformation_rule 7 Cs Ds :=
  select Cs (mbsc (var X) T' V) CsI /\ select CsI (dedc T (var X)) CsII /\
  _not(T = T') /\ subset T T' /\
  Ds = cons (dedc T V) (cons (mbsc (var X) T V) CsI)
  %/\ printstr "\nT7 Ra " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
;
% Rb
transformation_rule 8 Cs Ds :=
  select Cs (mbsc (var X) T' V) CsI /\ select CsI (dedc T (var X)) CsII /\
  _not(T = T') /\ subset T T' /\ sub_term_list W T /\
  Ds = cons (dedc T W) (cons (mbsc (var X) T W) (cons (mbsc W T' V) CsI))
  %/\ printstr "\nT8 Rb " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
;
% Rc
% 1. Checking V = V' is not necessary because of simplication_rule already removed two similar membership constraint
transformation_rule 9 Cs Ds :=
  select Cs (mbsc (var X) T V') CsI /\ select CsI (mbsc (var X) T V) CsII /\ select CsII (dedc T (var X)) CsIII /\
  get_T_var Cs (var X) nil TVar /\ subset T TVar /\
  Ds = cons (mbsc V T V') CsI
  %/\ printstr "\nT9 Rc " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
.

Define cs_apply : list sub_pair -> constraint -> constraint -> prop by 
cs_apply Subst (dedc T1 U1) (dedc T2 U2) :=
  copylist Subst T1 T2 /\ copyterm Subst U1 U2 ;
cs_apply Subst (mbsc U1 T1 V1) (mbsc U2 T2 V2) := 
  copyterm Subst U1 U2 /\ copylist Subst T1 T2 /\ copyterm Subst V1 V2 .

Define cs_apply_list : list sub_pair -> list constraint -> list constraint -> prop by 
cs_apply_list Subst nil nil ; 
cs_apply_list Subst (cons C L) (cons D R) :=
  cs_apply Subst C D /\ cs_apply_list Subst L R.

Define unify_constraint : list tm -> list constraint -> constraint -> list constraint -> list constraint -> list sub_pair -> list sub_pair -> prop
by
% reverse Pre PreI /\ append PreI Post CsL seems to be faster
unify_constraint Vs Pre (dedc T U) Post Ds SubstIn SubstOut :=
  unify_list Vs T U Subst /\
  compose Vs SubstIn Subst SubstOut /\
  append Pre Post CsL /\
  cs_apply_list Subst CsL Ds
  %/\ printstr "\nUnify " /\ append Pre (cons (dedc T U) Post) CsLI /\ cs_print_list_cst CsLI /\ cs_print_list_cst Ds
;
unify_constraint Vs Pre (dedc T V) Post Ds SubstIn SubstOut :=
  sub_term_list (aen V (var X)) T /\
  Subst = (cons (sub (var X) (pub (var X))) nil) /\
  compose Vs SubstIn Subst SubstOut /\
  append Pre (cons (dedc T V) Post) CsL /\
  cs_apply_list Subst CsL Ds
  %/\ printstr "\nUnify Pub " /\ append Pre (cons (dedc T V) Post) CsLI /\ cs_print_list_cst CsLI /\ cs_print_list_cst Ds
.

Define separate : list constraint -> list constraint -> list constraint -> list constraint -> prop by
separate Pre nil Pre nil ;
separate Pre (cons Cs CsL) NewPre NewPost :=
  separate Pre CsL NewPreI NewPostI /\
  _if (Cs = dedc T (var X) \/ Cs = mbsc V T U)
    (NewPre = cons Cs NewPreI /\ NewPost = NewPostI)
    (NewPre = NewPreI /\ NewPost = cons Cs NewPostI).

% When constructing constraint system, decomposing pair is needed in T
% Simplication rules and Transformation rule do not change T
Define cs_solve : list tm -> list constraint -> list constraint -> list sub_pair -> list sub_pair -> list constraint -> list constraint -> prop by
cs_solve Vs Pre Post SubstIn SubstOut LoopDedcIn LoopMbscIn :=
  %printstr "\nBefore Trim: " /\ cs_print_list_cst Post /\
  simplication_rule Post PostI /\
  %printstr "\nAfter Trim: " /\ cs_print_list_cst PostI /\
  append Pre PostI CsL /\
  _if (cs_solved_form CsL) (SubstOut = SubstIn)
    (
      separate Pre PostI PreI NewPost /\
      _if (NewPost = nil) (transformation_rule TR CsL Ds /\ cs_solve Vs nil Ds SubstIn SubstOut LoopDedcIn LoopMbscIn)
      (
	NewPost = cons Cs PostII /\
	(
	  (unify_constraint Vs PreI Cs PostII Ds SubstIn NewSubst /\ NewPre = nil /\ LoopDedcOut = LoopDedcIn /\ LoopMbscOut = LoopMbscIn) \/
	  (transformation_rule_loop_dedc Cs PostII Ds LoopDedcIn LoopDedcOut /\ NewSubst = SubstIn /\ LoopMbscOut = LoopMbscIn /\ NewPre = PreI) \/
	  (transformation_rule_loop_mbsc Cs PostII Ds LoopMbscIn LoopMbscOut /\ NewSubst = SubstIn /\ LoopDedcOut = LoopDedcIn /\ NewPre = PreI)
	) /\
	cs_solve Vs NewPre Ds NewSubst SubstOut LoopDedcOut LoopMbscOut
      )
    ) .

Define cs_decompose_pair : list constraint -> list constraint -> prop by
cs_decompose_pair nil nil ;
cs_decompose_pair (cons (mbsc V T U) CsLIn) (cons (mbsc V T U) CsLOut) := cs_decompose_pair CsLIn CsLOut ;
cs_decompose_pair (cons (dedc T U) CsLIn) (cons (dedc T' U) CsLOut) := decpr T T' /\ cs_decompose_pair CsLIn CsLOut .

Define cs_solve_constraints : list tm -> list constraint -> list sub_pair -> prop
by
cs_solve_constraints Vs CsL Subst :=
  id_subst Vs IdSubst /\
  %cs_decompose_pair CsL CsLI /\
  %cs_solve Vs nil CsLI IdSubst Subst nil nil
  cs_solve Vs nil CsL IdSubst Subst nil nil
.

Define cs_get_var_cst : constraint -> list tm -> list tm -> prop by 
cs_get_var_cst (dedc T U) VarIn VarOut := get_var U VarIn VarOut ; 
cs_get_var_cst (mbsc V T U) VarIn VarOut := get_var U VarIn VarOut.

Define cs_get_var_csts : list constraint -> list tm -> list tm -> prop by 
cs_get_var_csts nil VarIn VarIn ; 
cs_get_var_csts (cons C L) VarIn VarOut :=
  cs_get_var_cst C VarIn Vs /\ 
  cs_get_var_csts L Vs VarOut.

Define cs_constraints_vars : list constraint -> list tm -> prop by 
cs_constraints_vars Cs Vars :=
  cs_get_var_csts Cs nil Vs /\ reverse Vs Vars.
