%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SPEC                                                                     
% Copyright (C) 2011-2017 Alwen Tiu, Ross Horne, Nam Nguyen
%
% This program is free software; you can redistribute it and/or modify     
% it under the terms of the GNU General Public License as published by     
% the Free Software Foundation; either version 2 of the License, or        
% (at your option) any later version.                                      
%
% This program is distributed in the hope that it will be useful,          
% but WITHOUT ANY WARRANTY; without even the implied warranty of           
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
% GNU General Public License for more details.                             
%
% You should have received a copy of the GNU General Public License        
% along with this code; if not, write to the Free Software Foundation,     
% Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA             
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#include "intruder.def".

% Define membership constraints
Type mbsc tm -> list tm -> tm -> constraint.
Type dedc list tm -> tm -> constraint.

Define print_cs : constraint -> prop
by  
print_cs (dedc S M) := plist S /\ printstr " |- " /\ print_term M ;
print_cs (mbsc V T U) := print_term V /\ printstr " Bd({" /\ plist T /\ printstr "} , " /\ print_term U /\ printstr ")" .
 
Define plist_csl : list constraint -> prop
by
plist_csl nil ;
plist_csl (cons X nil) := print_cs X ; 
plist_csl (cons X (cons Y L)) :=
  print_cs X /\
  printstr " ; \n" /\
  plist_csl (cons Y L).

Define cs_print_list_cst : list constraint -> prop
by
cs_print_list_cst L :=
  printstr"[" /\ plist_csl L /\ printstr "]\n".

Define cs_apply : list sub_pair -> constraint -> constraint -> prop by 
cs_apply Subst (dedc T1 U1) (dedc T2 U2) :=
  copylist Subst T1 T2 /\ copyterm Subst U1 U2 ;
cs_apply Subst (mbsc U1 T1 V1) (mbsc U2 T2 V2) := 
  copyterm Subst U1 U2 /\ copylist Subst T1 T2 /\ copyterm Subst V1 V2 .

Define cs_apply_list : list sub_pair -> list constraint -> list constraint -> prop by 
cs_apply_list Subst nil nil ; 
cs_apply_list Subst (cons C L) (cons D R) :=
  cs_apply Subst C D /\ cs_apply_list Subst L R.

% Get variable list in term list
Define get_var_list_tm : list tm -> list tm -> list tm -> prop by
get_var_list_tm nil VarIn VarIn;
get_var_list_tm (cons T L) VarIn VarOut :=
  get_var T VarIn Vs /\
  get_var_list_tm L Vs VarOut.

% Get Tx
Define get_T_var : list constraint -> tm -> list tm -> list tm -> prop by
get_T_var nil Var TIn TOut ;
get_T_var (cons Cs CsL) Var TIn TOut :=
  (Cs = dedc T U \/ Cs = mbsc V T U) /\
  _if (get_var_list_tm T nil TVars /\ _not(det_mem Var TVars) /\ get_var U nil UVars /\ det_mem Var UVars)
    (
      _if (TIn = nil \/ subset T TIn) (get_T_var CsL Var T TOut) (get_T_var CsL Var TIn TOut)
    )
    (get_T_var CsL Var TVarIn TVarOut).

% Check if a term is subterm of another term
Define sub_term : tm -> tm -> prop by
sub_term (ct X) (ct X) ;
sub_term (nm X) (nm X) ;
sub_term (var X) (var X) ;
sub_term T (pr X Y) := T = pr X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (en X Y) := T = en X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (aen X Y) := T = aen X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (pub X) := T = pub X \/ sub_term T X ;
sub_term T (blind X Y) := T = blind X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (sign X Y) := T = sign X Y \/ sub_term T X \/ sub_term T Y ;
sub_term T (hs X) := T = hs X \/ sub_term T X ;
sub_term T (mac X Y) := T = mac X Y \/ sub_term T X \/ sub_term T Y .

% Check if a term is subterm in a list of term
Define sub_term_list : tm -> list tm -> prop by
sub_term_list S (cons T L) := sub_term S T \/ sub_term_list S L.

% Simplication rules for membership constraints
% Note: In a set of constraints in simplified form, each membership constraint is of the form mbsc (var X) T U
Define simplication_rule : list constraint -> list constraint -> list constraint -> list sub_pair -> list sub_pair -> list tm ->
prop by
simplication_rule CsIn nil CsIn SubstIn SubstIn Vs ;

% Sax
simplication_rule Processed (cons (mbsc V T U) CsL) CsOut SubstIn SubstOut Vs :=
  _not (V = U \/ V = blind M N \/ V = pr M N) /\
  _if (_cut(select CsL (mbsc V T U) CsLI))
    (simplication_rule Processed CsL CsOut SubstIn SubstOut Vs)
    (
      simplication_rule (cons (mbsc V T U) Processed) CsL CsOut SubstIn SubstOut Vs
    ) ;
simplication_rule Processed (cons (mbsc U T U) CsL) CsOut SubstIn SubstOut Vs :=
  simplication_rule Processed CsL CsOut SubstIn SubstOut Vs;

% Sbd
simplication_rule Processed (cons (mbsc (blind U V) T W) CsL) CsOut SubstIn SubstOut Vs :=
  _not (W = blind U V) /\
  append Processed (cons (dedc T V) (cons (mbsc U T W) CsL)) CsIn /\
  simplication_rule nil CsIn CsOut SubstIn SubstOut Vs;

% Sbd - Unify
%simplication_rule Processed (cons (mbsc (blind U V) T W) CsL) CsOut SubstIn SubstOut Vs :=
%  _not (W = blind U V) /\
%  unify nil (blind U V) W Vs Subst /\
%  compose Vs SubstIn Subst SubstInI /\
%  append Processed CsL CsLI /\
%  cs_apply_list Subst CsLI Ds /\
%  simplication_rule nil Ds CsOut SubstInI SubstOut Vs ;
% Sbd - Unify
simplication_rule Processed (cons (mbsc U T W) CsL) CsOut SubstIn SubstOut Vs :=
  _not (W = U \/ U = var X) /\
  unify nil U W Vs Subst /\
  compose Vs SubstIn Subst SubstInI /\
  append Processed CsL CsLI /\
  cs_apply_list Subst CsLI Ds /\
  simplication_rule nil Ds CsOut SubstInI SubstOut Vs ;
% Sleft
simplication_rule Processed (cons (mbsc (pr U V) T W) CsL) CsOut SubstIn SubstOut Vs :=
  _not (pr U V = W) /\
  append Processed (cons (mbsc U T W) CsL) CsIn /\
  simplication_rule nil CsIn CsOut SubstIn SubstOut Vs;
% Sright
simplication_rule Processed (cons (mbsc (pr U V) T W) CsL) CsOut SubstIn SubstOut Vs :=
  _not (pr U V = W) /\
  append Processed (cons (mbsc V T W) CsL) CsIn /\
  simplication_rule nil CsIn CsOut SubstIn SubstOut Vs;
% Rax
simplication_rule Processed (cons (dedc T U) CsL) CsOut SubstIn SubstOut Vs :=
  (det_mem U T \/ U = ct M) /\ simplication_rule Processed CsL CsOut SubstIn SubstOut Vs;
% Rtriv
simplication_rule Processed (cons (dedc T U) CsL) CsOut SubstIn SubstOut Vs :=
  _not (det_mem U T) /\ _not(U = ct M) /\
  append Processed CsL CsIn /\
  _if (_cut(select CsIn (dedc T' U) CsLI))
    (
      _if (subset T T')
	(
	  simplication_rule (cons (dedc T U) nil) CsLI CsOut SubstIn SubstOut Vs
	)
	(
	  simplication_rule Processed CsL CsOut SubstIn SubstOut Vs
	)
    )
    (
      simplication_rule (cons (dedc T U) Processed) CsL CsOut SubstIn SubstOut Vs
    ).
% Sf is not necessary to check
% Need to check Scycle

% Solved Form
Define cs_solved_form : list constraint -> prop by
%cs_solved_form CsL :=
%  forall Cs, member Cs CsL -> (
%    exists T, exists X, (
%      Cs = dedc T (var X) \/
%      (
%	exists U, Cs = mbsc (var X) T U /\ member (dedc T (var X)) CsL /\
%	_not (
%	  exists TI, exists UI, member (mbsc (var X) TI UI) CsL /\ _not(TI = T /\ UI = U)
%	)
%      )
%    )
%  )
%.
% Using forall will cause Bedwyr error: Prover.Level_inconsistency
cs_solved_form nil ;
cs_solved_form CsL :=
  _not (CsL = nil) /\
  _not (
    member (dedc T U) CsL /\
    _not (U = var X)
  ) /\
  _not (
    select CsL (mbsc V T U) CsLI /\
    (
      _not (V = var X) \/
      _not (member (dedc T V) CsLI) \/
      member (mbsc V T' U') CsLI
    )
  ).

Define transformation_rule_loop_dedc : constraint -> list constraint -> list constraint -> list constraint -> list constraint -> prop by
% Rf
transformation_rule_loop_dedc (dedc T M) CsL Ds LoopIn LoopOut :=
  (M = blind U V \/ M = sign U V \/ M = pr U V \/ M = en U V \/ M = aen U V) /\
  _not(det_mem (dedc T M) LoopIn) /\
  LoopOut = cons (dedc T M) LoopIn /\
  Ds = cons (dedc T U) (cons (dedc T V) CsL)
  %/\ printstr "\nT3 " /\ cs_print_list_cst (cons (dedc T M) CsL) /\ cs_print_list_cst Ds
;
% Rf
transformation_rule_loop_dedc (dedc T M) CsL Ds LoopIn LoopOut :=
  (M = pub V \/ M = hs V) /\
  _not (det_mem (dedc T M) LoopIn) /\
  LoopOut = cons (dedc T M) LoopIn /\
  Ds = cons (dedc T V) CsL
  %/\ printstr " T3 Pub/Hash " /\ cs_print_list_cst (cons (dedc T (pub V)) CsL) /\ cs_print_list_cst Ds
;
% Rbd
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (blind V U) T) /\
  Ds = cons (dedc T (blind V U)) (cons (dedc T U) CsL)
  %/\ printstr "\nT4 Blind " /\ cs_print_list_cst (cons (dedc T V) CsL) /\ cs_print_list_cst Ds
;
% Rget
%transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
%  _distinct(sub_term_list (sign V U) T) /\
%  _not(det_mem (dedc T (sign V U)) LoopIn) /\
%  LoopOut = cons (dedc T (sign V U)) LoopIn /\
%  Ds = cons (dedc T (sign V U)) CsL
%  %/\ printstr " T5 Sign "
%;
% Rpair
transformation_rule_loop_dedc (dedc T U) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (pr M N) T) /\ (U = M \/ U = N) /\
  _not(det_mem (dedc T (pr M N)) LoopIn) /\
  LoopOut = cons (dedc T (pr M N)) LoopIn /\
  Ds = cons (dedc T (pr M N)) CsL
  %/\ printstr " T10 Pair " %/\ cs_print_list_cst Ds
;
% Rdec
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (en V U) T) /\
  _not(det_mem (dedc T (en V U)) LoopIn) /\
  LoopOut = cons (dedc T (en V U)) LoopIn /\
  Ds = cons (dedc T (en V U)) (cons (dedc T U) CsL)
  %/\ printstr " T11 Enc "
;
% Radec
transformation_rule_loop_dedc (dedc T V) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (aen V (pub U)) T) /\
  _not(det_mem (dedc T (aen V (pub U))) LoopIn) /\
  LoopOut = cons (dedc T (aen V (pub U))) LoopIn /\
  Ds = cons (dedc T (aen V (pub U))) (cons (dedc T U) CsL)
  %/\ printstr " T12 Aen " %/\ cs_print_list_cst Ds
.

Define transformation_rule_loop_mbsc : constraint -> list constraint -> list constraint -> list constraint -> list constraint -> prop by
% Rbdsgn
% In the rules Rbdsgn and Ra, Rb, Rc, pushing membership constraints before deducibility constraints might help to reduce running time
transformation_rule_loop_mbsc (dedc T (sign V U)) CsL Ds LoopIn LoopOut :=
  _distinct(sub_term_list (sign W U) T) /\ _not(V = W \/ det_mem (dedc T (sign V U)) LoopIn) /\
  LoopOut = cons (dedc T (sign V U)) LoopIn /\
  Ds = cons (dedc T (sign W U)) (cons (mbsc W T V) CsL)
  %/\ printstr "\nT6 Bdsgn " /\ cs_print_list_cst (cons (dedc T (sign V U)) CsL) /\ cs_print_list_cst Ds
.

Define transformation_rule : nat -> list constraint -> list constraint -> prop by
% Ra
% Checking V = var X is not necessary because of simplication_rule already removed this case
transformation_rule 7 Cs Ds :=
  select Cs (mbsc (var X) T' V) CsI /\ select CsI (dedc T (var X)) CsII /\
  _not(T = T') /\ subset T T' /\
  Ds = cons (dedc T V) (cons (mbsc (var X) T V) CsI)
  %/\ printstr "\nT7 Ra " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
;
% Rb
transformation_rule 8 Cs Ds :=
  select Cs (mbsc (var X) T' V) CsI /\ select CsI (dedc T (var X)) CsII /\
  _not(T = T') /\ subset T T' /\ _distinct(sub_term_list W T) /\
  Ds = cons (dedc T W) (cons (mbsc (var X) T W) (cons (mbsc W T' V) CsI))
  %/\ printstr "\nT8 Rb " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
;
% Rc
% 1. Checking V = V' is not necessary because of simplication_rule already removed two similar membership constraint
transformation_rule 9 Cs Ds :=
  select Cs (mbsc (var X) T V') CsI /\ select CsI (mbsc (var X) T V) CsII /\ select CsII (dedc T (var X)) CsIII /\
  get_T_var Cs (var X) nil TVar /\ subset T TVar /\
  Ds = cons (mbsc V T V') CsI
  %/\ printstr "\nT9 Rc " /\ cs_print_list_cst Cs /\ cs_print_list_cst Ds
.

Define unify_constraint : list tm -> list constraint -> constraint -> list constraint -> list constraint -> list sub_pair -> list sub_pair -> prop
by
unify_constraint Vs Pre (dedc T U) Post Ds SubstIn SubstOut :=
  unify_list Vs T U Subst /\
  compose Vs SubstIn Subst SubstOut /\
  append Pre Post CsL /\
  cs_apply_list Subst CsL Ds
  %/\ printstr "\nUnify " /\ append Pre (cons (dedc T U) Post) CsLI /\ cs_print_list_cst CsLI /\ cs_print_list_cst Ds
;
unify_constraint Vs Pre (dedc T V) Post Ds SubstIn SubstOut :=
  _cut(sub_term_list (aen V (var X)) T) /\
  Subst = (cons (sub (var X) (pub (var X))) nil) /\
  compose Vs SubstIn Subst SubstOut /\
  append Pre (cons (dedc T V) Post) CsL /\
  cs_apply_list Subst CsL Ds
  %/\ printstr "\nUnify Pub " /\ append Pre (cons (dedc T V) Post) CsLI /\ cs_print_list_cst CsLI /\ cs_print_list_cst Ds
.

Define separate : list constraint -> list constraint -> list constraint -> prop by
separate nil nil nil ;
separate (cons Cs CsL) Pre Post :=
  separate CsL NewPre NewPost /\
  _if (Cs = dedc T (var X) \/ Cs = mbsc V T U)
    (Pre = cons Cs NewPre /\ Post = NewPost)
    (Pre = NewPre /\ Post = cons Cs NewPost).

% Note: 09/02/2017: Pre is redundant - Need to remove
% Remove in both unify function
% Simplication rules and Transformation rule do not change T
Define cs_solve : list tm -> list constraint -> list constraint -> list sub_pair -> list sub_pair -> list constraint -> list constraint -> prop by
cs_solve Vs Pre Post SubstInX SubstOut LoopDedcIn LoopMbscIn :=
  append Pre Post PreCsL /\
  %printstr "\nBefore Simplification: " /\ cs_print_list_cst PreCsL /\
  simplication_rule nil PreCsL CsL SubstInX SubstIn Vs /\
  %printstr "\nAfter Simplification: " /\ cs_print_list_cst CsL /\
  _if (cs_solved_form CsL /\ printstr "\n\n" /\ cs_print_list_cst CsL) (SubstOut = SubstIn)
    (
      separate CsL PreI NewPost /\
      _if (NewPost = nil) (transformation_rule TR CsL Ds /\ cs_solve Vs nil Ds SubstIn SubstOut LoopDedcIn LoopMbscIn)
      (
	NewPost = cons Cs PostII /\
	(
	  (unify_constraint Vs PreI Cs PostII Ds SubstIn NewSubst /\ NewPre = nil /\ LoopDedcOut = LoopDedcIn /\ LoopMbscOut = LoopMbscIn) \/
	  (transformation_rule_loop_dedc Cs PostII Ds LoopDedcIn LoopDedcOut /\ NewSubst = SubstIn /\ LoopMbscOut = LoopMbscIn /\ NewPre = PreI) \/
	  (transformation_rule_loop_mbsc Cs PostII Ds LoopMbscIn LoopMbscOut /\ NewSubst = SubstIn /\ LoopDedcOut = LoopDedcIn /\ NewPre = PreI)
	) /\
	cs_solve Vs NewPre Ds NewSubst SubstOut LoopDedcOut LoopMbscOut
      )
    ) .

% Decompose pair in constraint system
% The initial constraint system does not contain membership constraint
% Pair decomposing is not necessary 
Define cs_decompose_pair : list constraint -> list constraint -> prop by
cs_decompose_pair nil nil ;
cs_decompose_pair (cons (dedc T U) CsLIn) (cons (dedc T' U) CsLOut) := decpr T T' /\ cs_decompose_pair CsLIn CsLOut .

% Remove redundant constraints
% The initial constraint system does not contain membership constraint
Define cs_trim_cst : list constraint -> list tm -> list constraint -> prop by 
cs_trim_cst nil Rhs nil ;
cs_trim_cst (cons (dedc T U) L) Rhs Ds :=
  _if (U = ct X)
    (cs_trim_cst L Rhs Ds)
    (
      _if (det_mem U Rhs)
      (cs_trim_cst L Rhs Ds)
      (cs_trim_cst L (cons U Rhs) Cs /\ Ds = (cons (dedc T U) Cs))
    ) .

Define cs_solve_constraints : list tm -> list constraint -> list sub_pair -> prop
by
cs_solve_constraints Vs CsL Subst :=
  % This step might be redundant because of simplication_rule
  % cs_trim_cst CsL nil CsLI /\
  id_subst Vs IdSubst /\
  cs_solve Vs nil CsL IdSubst Subst nil nil
.

Define cs_get_var_cst : constraint -> list tm -> list tm -> prop by 
cs_get_var_cst (dedc T U) VarIn VarOut := get_var U VarIn VarOut ; 
cs_get_var_cst (mbsc V T U) VarIn VarOut := get_var U VarIn VarOut.

Define cs_get_var_csts : list constraint -> list tm -> list tm -> prop by 
cs_get_var_csts nil VarIn VarIn ; 
cs_get_var_csts (cons C L) VarIn VarOut :=
  cs_get_var_cst C VarIn Vs /\ 
  cs_get_var_csts L Vs VarOut.

Define cs_constraints_vars : list constraint -> list tm -> prop by 
cs_constraints_vars Cs Vars :=
  cs_get_var_csts Cs nil Vs /\ reverse Vs Vars.

%
%
%
%
%

%
%
%
%
%

%
%
%
%
%

Kind constraint_pair type.

% Define membership constraints
Type mbsc_pair thy_pair -> list thy_pair -> thy_pair -> constraint_pair.
Type dedc_pair list thy_pair -> thy_pair -> constraint_pair.

% Substitutions
Kind subst_pair type. % Substitution pair
Type mpsub list sub_pair -> list sub_pair -> subst_pair.

Define cs_apply_pair : subst_pair -> constraint_pair -> constraint_pair -> prop by 
cs_apply_pair (mpsub SubstL SubstR) (dedc_pair T1 (mp U1 V1)) (dedc_pair T2 (mp U2 V2)) :=
  apply_subst_thy SubstL SubstR T1 T2 /\
  copyterm SubstL U1 U2 /\ copyterm SubstR V1 V2 ;
cs_apply_pair (mpsub SubstL SubstR) (mbsc_pair (mp U1 V1) T1 (mp M1 N1)) (mbsc_pair (mp U2 V2) T2 (mp M2 N2)) :=
  apply_subst_thy SubstL SubstR T1 T2 /\
  copyterm SubstL U1 U2 /\ copyterm SubstR V1 V2 /\
  copyterm SubstL M1 M2 /\ copyterm SubstR N1 N2 .

Define cs_apply_list_pair : subst_pair -> list constraint_pair -> list constraint_pair -> prop by 
cs_apply_list_pair Subst nil nil ; 
cs_apply_list_pair Subst (cons C L) (cons D R) :=
  cs_apply_pair Subst C D /\ cs_apply_list_pair Subst L R.

Define print_subst_pair : subst_pair -> prop by
print_subst_pair (mpsub SubstL SubstR) := 
  printstr "\nSubst Left: " /\ print_subst SubstL /\ printstr " - Subst Right: " /\ print_subst SubstR /\
  printstr "\n------------------------------------------------------------------------------------------------------------------------\n".

Define print_cst_pair : constraint_pair -> prop by
print_cst_pair (dedc_pair T (mp U1 U2)) := printstr "\n" /\ print_thy T /\ printstr " |- " /\ print_term U1 /\ printstr " <-> " /\ print_term U2 ;
print_cst_pair (mbsc_pair (mp V1 V2) T (mp U1 U2)) :=
  printstr "\n" /\ print_term V1 /\ printstr " <-> " /\ print_term V2 /\ printstr "   Bd   " /\
  print_thy T /\ printstr "   ,   " /\ print_term U1 /\ printstr " <-> " /\ print_term U2 .

Define print_cst_pair_list : list constraint_pair -> prop by
print_cst_pair_list nil := printstr "\n" ;
print_cst_pair_list (cons Cs CsL) := print_cst_pair Cs /\ print_cst_pair_list CsL .

% Get Tx
Define get_T_var_pair : list constraint_pair -> tm -> list thy_pair -> list thy_pair -> prop by
get_T_var_pair nil Var TIn TOut ;
get_T_var_pair (cons Cs CsL) Var TIn TOut :=
  (Cs = dedc_pair T (mp U1 U2) \/ Cs = mbsc_pair V T (mp U1 U2)) /\
  split_thy T T1 T2 /\
  _if (get_var_list_tm T1 nil TVars1 /\ _not(det_mem Var TVars1) /\ get_var U1 nil UVars1 /\ det_mem Var UVars1 /\
       get_var_list_tm T2 nil TVars2 /\ _not(det_mem Var TVars2) /\ get_var U2 nil UVars2 /\ det_mem Var UVars2)
    (
      _if (TIn = nil \/ subset T TIn) (get_T_var_pair CsL Var T TOut) (get_T_var_pair CsL Var TIn TOut)
    )
    (get_T_var_pair CsL Var TVarIn TVarOut).

% Check if a term is subterm of another term
Define sub_term_pair : thy_pair -> thy_pair -> prop by
sub_term_pair (mp (ct X) (ct Y)) (mp (ct X) (ct Y)) ;
sub_term_pair (mp (nm X) (nm Y)) (mp (nm X) (nm Y)) ;
sub_term_pair (mp (var X) (var Y)) (mp (var X) (var Y)) ;
sub_term_pair T (mp (pr X1 Y1) (pr X2 Y2)) := T = mp (pr X1 Y1) (pr X2 Y2) \/ sub_term_pair T (mp X1 X2) \/ sub_term_pair T (mp Y1 Y2) ;
sub_term_pair T (mp (en X1 Y1) (en X2 Y2)) := T = mp (en X1 Y1) (en X2 Y2) \/ sub_term_pair T (mp X1 X2) \/ sub_term_pair T (mp Y1 Y2) ;
sub_term_pair T (mp (aen X1 Y1) (aen X2 Y2)) := T = (mp (aen X1 Y1) (aen X2 Y2)) \/ sub_term_pair T (mp X1 X2) \/ sub_term_pair T (mp Y1 Y2) ;
sub_term_pair T (mp (pub X) (pub Y)) := T = mp (pub X) (pub Y) \/ sub_term_pair T (mp X Y) ;
sub_term_pair T (mp (blind X1 Y1) (blind X2 Y2)) := T = mp (blind X1 Y1) (blind X2 Y2) \/ sub_term_pair T (mp X1 X2) \/ sub_term_pair T (mp Y1 Y2) ;
sub_term_pair T (mp (sign X1 Y1) (sign X2 Y2)) := T = mp (sign X1 Y1) (sign X2 Y2) \/ sub_term_pair T (mp X1 X2) \/ sub_term_pair T (mp Y1 Y2) ;
sub_term_pair T (mp (hs X) (hs Y)) := T = mp (hs X) (hs Y) \/ sub_term_pair T (mp X Y) ;
sub_term_pair T (mp (mac X1 Y1) (mac X2 Y2)) := T = mp (mac X1 Y1) (mac X2 Y2) \/ sub_term_pair T (mp X1 X2) \/ sub_term_pair T (mp Y1 Y2) .

% Check if a term is subterm in a list of term
Define sub_term_list_pair : thy_pair -> list thy_pair -> prop by
sub_term_list_pair S (cons T L) := sub_term_pair S T \/ sub_term_list_pair S L.

%----------------------------------------------------------------------------------------------------------------------%
% TRANSFORMATION RULES
%----------------------------------------------------------------------------------------------------------------------%

Define transformation_rule_loop_dedc_pair : constraint_pair -> list constraint_pair -> list constraint_pair ->
list constraint_pair -> list constraint_pair -> subst_pair -> subst_pair -> list tm -> list constraint_pair ->
list constraint_pair -> list tm -> prop by
% Rf
transformation_rule_loop_dedc_pair (dedc_pair T M) CsL Ds LoopIn LoopOut SubstIn SubstIn Vs Pre Pre Vs :=
  (M = mp (blind U1 V1) (blind U2 V2) \/ M = mp (sign U1 V1) (sign U2 V2) \/ M = mp (pr U1 V1) (pr U2 V2) \/ M = mp (en U1 V1) (en U2 V2) \/ M = mp (aen U1 V1) (aen U2 V2)) /\
  _not(det_mem (dedc_pair T M) LoopIn) /\
  LoopOut = cons (dedc_pair T M) LoopIn /\
  Ds = cons (dedc_pair T (mp U1 U2)) (cons (dedc_pair T (mp V1 V2)) CsL)
  %/\ printstr "\nRf Blind/Sign/Pair/Enc/Aenc\n"
;
% Rf
%transformation_rule_loop_dedc_pair (dedc_pair T (mp (blind U1 V1) (var Y))) CsL Ds LoopIn LoopOut (mpsub SubstInL SubstInR) (mpsub SubstOutL SubstOutR) Vs Pre NewPre NewVs :=
%  _not(det_mem (dedc_pair T (mp (blind U1 V1) RHS)) LoopIn) /\
%  LoopOut = cons (dedc_pair T (mp (blind U1 V1) RHS)) LoopIn /\
%  nabla y1, nabla y2,
%    NewVs = cons (var y1) (cons (var y2) Vs) /\
%    Subst = cons (sub (var Y) (blind (var y1) (var y2))) nil /\
%    SubstOutL = cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInL) /\
%    compose NewVs (cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInR)) Subst SubstOutR /\
%    cs_apply_list_pair (mpsub nil Subst) Pre NewPre /\
%    cs_apply_list_pair (mpsub nil Subst) CsL CsLI /\
%    Ds = cons (dedc_pair T (mp U1 (var y1))) (cons (dedc_pair T (mp V1 (var y2))) CsLI)
    %/\ printstr "\nRf Blind Var\n"
%;
% Rf
%transformation_rule_loop_dedc_pair (dedc_pair T (mp (sign U1 V1) (var Y))) CsL Ds LoopIn LoopOut (mpsub SubstInL SubstInR) (mpsub SubstOutL SubstOutR) Vs Pre NewPre NewVs :=
%  _not(det_mem (dedc_pair T (mp (sign U1 V1) RHS)) LoopIn) /\
%  LoopOut = cons (dedc_pair T (mp (sign U1 V1) RHS)) LoopIn /\
%  nabla y1, nabla y2,
%    NewVs = cons (var y1) (cons (var y2) Vs) /\
%    Subst = cons (sub (var Y) (sign (var y1) (var y2))) nil /\
%    SubstOutL = cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInL) /\
%    compose NewVs (cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInR)) Subst SubstOutR /\
%    cs_apply_list_pair (mpsub nil Subst) Pre NewPre /\
%    cs_apply_list_pair (mpsub nil Subst) CsL CsLI /\
%    Ds = cons (dedc_pair T (mp U1 (var y1))) (cons (dedc_pair T (mp V1 (var y2))) CsLI)
    %/\ printstr "\nRf Sign Var\n" /\ print_subst_pair (mpsub SubstOutL SubstOutR)
%;
% Rf
%transformation_rule_loop_dedc_pair (dedc_pair T (mp (pr U1 V1) (var Y))) CsL Ds LoopIn LoopOut (mpsub SubstInL SubstInR) (mpsub SubstOutL SubstOutR) Vs Pre NewPre NewVs :=
%  _not(det_mem (dedc_pair T (mp (pr U1 V1) RHS)) LoopIn) /\
%  LoopOut = cons (dedc_pair T (mp (pr U1 V1) RHS)) LoopIn /\
%  nabla y1, nabla y2, NewVs = cons (var y1) (cons (var y2) Vs) /\
%    Subst = cons (sub (var Y) (pr (var y1) (var y2))) nil /\
%    SubstOutL = cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInL) /\
%    compose NewVs (cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInR)) Subst SubstOutR /\
%    cs_apply_list_pair (mpsub nil Subst) Pre NewPre /\
%    cs_apply_list_pair (mpsub nil Subst) CsL CsLI /\
%    Ds = cons (dedc_pair T (mp U1 (var y1))) (cons (dedc_pair T (mp V1 (var y2))) CsLI)
    %/\ printstr "\nRf Pair Var\n"
%;
% Rf
%transformation_rule_loop_dedc_pair (dedc_pair T (mp (en U1 V1) (var Y))) CsL Ds LoopIn LoopOut (mpsub SubstInL SubstInR) (mpsub SubstOutL SubstOutR) Vs Pre NewPre NewVs :=
%  _not(det_mem (dedc_pair T (mp (en U1 V1) RHS)) LoopIn) /\
%  LoopOut = cons (dedc_pair T (mp (en U1 V1) RHS)) LoopIn /\
%  nabla y1, nabla y2,
%    NewVs = cons (var y1) (cons (var y2) Vs) /\
%    Subst = cons (sub (var Y) (en (var y1) (var y2))) nil /\
%    SubstOutL = cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInL) /\
%    compose NewVs (cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInR)) Subst SubstOutR /\
%    cs_apply_list_pair (mpsub nil Subst) Pre NewPre /\
%    cs_apply_list_pair (mpsub nil Subst) CsL CsLI /\
%    Ds = cons (dedc_pair T (mp U1 (var y1))) (cons (dedc_pair T (mp V1 (var y2))) CsLI)
    %/\ printstr "\nRf Enc Var\n"
%;
% Rf
%transformation_rule_loop_dedc_pair (dedc_pair T (mp (aen U1 V1) (var Y))) CsL Ds LoopIn LoopOut (mpsub SubstInL SubstInR) (mpsub SubstOutL SubstOutR) Vs Pre NewPre NewVs :=
%  _not(det_mem (dedc_pair T (mp (aen U1 V1) RHS)) LoopIn) /\
%  LoopOut = cons (dedc_pair T (mp (aen U1 V1) RHS)) LoopIn /\
%  nabla y1, nabla y2,
%    NewVs = cons (var y1) (cons (var y2) Vs) /\
%    Subst = cons (sub (var Y) (aen (var y1) (var y2))) nil /\
%    SubstOutL = cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInL) /\
%    compose NewVs (cons (sub (var y1) (var y1)) (cons (sub (var y2) (var y2)) SubstInR)) Subst SubstOutR /\
%    cs_apply_list_pair (mpsub nil Subst) Pre NewPre /\
%    cs_apply_list_pair (mpsub nil Subst) CsL CsLI /\
%    Ds = cons (dedc_pair T (mp U1 (var y1))) (cons (dedc_pair T (mp V1 (var y2))) CsLI)
    %/\ printstr "\nRf Aenc Var\n"
%;
% Rf
transformation_rule_loop_dedc_pair (dedc_pair T (mp M1 M2)) CsL Ds LoopIn LoopOut SubstIn SubstIn Vs Pre Pre Vs :=
  (
    (M1 = pub V1 /\ M2 = pub V2) \/ (M1 = hs V1 /\ M2 = hs V2)
  ) /\
  _not (det_mem (dedc_pair T (mp M1 RHS)) LoopIn) /\
  LoopOut = cons (dedc_pair T (mp M1 M2)) LoopIn /\
  Ds = cons (dedc_pair T (mp V1 V2)) CsL
  %/\ printstr "\nRf Pub/Hash\n"
;
% Rf
transformation_rule_loop_dedc_pair (dedc_pair T (mp (pub V1) (var Y))) CsL Ds LoopIn LoopOut (mpsub SubstInL SubstInR) (mpsub SubstInL SubstOutR) Vs Pre NewPre Vs :=
  % We do not care about RHS in LoopIn/LoopOut
  _not (det_mem (dedc_pair T (mp (pub V1) RHS)) LoopIn) /\
  LoopOut = cons (dedc_pair T (mp (pub V1) (var Y))) LoopIn /\
  % (var Y) -> pub (var Y) U2
  Subst = (cons (sub (var Y) (pub (var Y))) nil) /\
  compose Vs SubstInR Subst SubstOutR /\
  % This rule is related to the RHS therefore we need to do substitution to both side, CsL and Pre
  cs_apply_list_pair (mpsub nil Subst) Pre NewPre /\
  cs_apply_list_pair (mpsub nil Subst) CsL CsLI /\
  Ds = cons (dedc_pair T (mp V1 (var Y))) CsLI
  %/\ printstr "\nRf Pub Var\n"
;
% Rf
transformation_rule_loop_dedc_pair (dedc_pair T (mp (hs V1) (var Y))) CsL Ds LoopIn LoopOut (mpsub SubstInL SubstInR) (mpsub SubstInL SubstOutR) Vs Pre NewPre Vs :=
  % We do not care about RHS in LoopIn/LoopOut
  _not (det_mem (dedc_pair T (mp (hs V1) RHS)) LoopIn) /\
  LoopOut = cons (dedc_pair T (mp (hs V1) (var Y))) LoopIn /\
  % (var Y) -> hs (var Y) U2
  Subst = (cons (sub (var Y) (hs (var Y))) nil) /\
  compose Vs SubstInR Subst SubstOutR /\
  % This rule is related to the RHS therefore we need to do substitution to both side, CsL and Pre
  cs_apply_list_pair (mpsub nil Subst) Pre NewPre /\
  cs_apply_list_pair (mpsub nil Subst) CsL CsLI /\
  Ds = cons (dedc_pair T (mp V1 (var Y))) CsLI
  %/\ printstr "\nRf Hash Var\n" /\ print_cst_pair (dedc_pair T (mp (hs V1) (var Y))) /\ print_cst_pair_list Ds
;
% Rbd
transformation_rule_loop_dedc_pair (dedc_pair T (mp V1 V2)) CsL Ds LoopIn LoopOut SubstIn SubstIn Vs Pre Pre Vs :=
  _distinct(sub_term_list_pair (mp (blind V1 U1) (blind V2 U2)) T) /\
  Ds = cons (dedc_pair T (mp (blind V1 U1) (blind V2 U2))) (cons (dedc_pair T (mp U1 U2)) CsL)
  %/\ printstr "\nRbd 1\n"
;
% Rpair
transformation_rule_loop_dedc_pair (dedc_pair T (mp U1 U2)) CsL Ds LoopIn LoopOut SubstIn SubstIn Vs Pre Pre Vs :=
  _distinct(sub_term_list_pair (mp (pr M1 N1) (pr M2 N2)) T) /\ ((U1 = M1 /\ U2 = M2) \/ (U1 = N1 /\ U2 = N2)) /\
  _not(det_mem (dedc_pair T (mp (pr M1 N1) (pr M2 N2))) LoopIn) /\
  LoopOut = cons (dedc_pair T (mp (pr M1 N1) (pr M2 N2))) LoopIn /\
  Ds = cons (dedc_pair T (mp (pr M1 N1) (pr M2 N2))) CsL
  %/\ printstr "\nRpair 1\n"
;
% Rdec
transformation_rule_loop_dedc_pair (dedc_pair T (mp V1 V2)) CsL Ds LoopIn LoopOut SubstIn SubstIn Vs Pre Pre Vs :=
  _distinct(sub_term_list_pair (mp (en V1 U1) (en V2 U2)) T) /\
  _not(det_mem (dedc_pair T (mp (en V1 U1) (en V2 U2))) LoopIn) /\
  LoopOut = cons (dedc_pair T (mp (en V1 U1) (en V2 U2))) LoopIn /\
  Ds = cons (dedc_pair T (mp (en V1 U1) (en V2 U2))) (cons (dedc_pair T (mp U1 U2)) CsL)
  %/\ printstr "\nRdec 1\n"
;
% Radec
transformation_rule_loop_dedc_pair (dedc_pair T (mp V1 V2)) CsL Ds LoopIn LoopOut SubstIn SubstIn Vs Pre Pre Vs :=
  _distinct(sub_term_list_pair (mp (aen V1 (pub U1)) (aen V2 (pub U2))) T) /\
  _not(det_mem (dedc_pair T (mp (aen V1 (pub U1)) (aen V2 (pub U2)))) LoopIn) /\
  LoopOut = cons (dedc_pair T (mp (aen V (pub U)) (aen V2 (pub U2)))) LoopIn /\
  Ds = cons (dedc_pair T (mp (aen V1 (pub U1)) (aen V2 (pub U2)))) (cons (dedc_pair T (mp U1 U2)) CsL) 
  %/\ printstr "\nRadec 1\n"
.

%----------------------------------------------------------------------------------------------------------------------%
% TRANSFORMATION RULES - MEMBERSHIP CONSTRAINT CREATION
%----------------------------------------------------------------------------------------------------------------------%

Define transformation_rule_loop_mbsc_pair : constraint_pair -> list constraint_pair -> list constraint_pair -> list constraint_pair ->
list constraint_pair -> subst_pair -> subst_pair -> list tm -> list constraint_pair -> list constraint_pair -> prop by
% Rbdsgn
transformation_rule_loop_mbsc_pair (dedc_pair T (mp (sign V1 U1) (sign V2 U2))) CsL Ds LoopIn LoopOut SubstIn SubstIn Vs Pre Pre :=
  _distinct(sub_term_list_pair (mp (sign W1 U1) (sign W2 U2)) T) /\
  % Check condition on the LHS
  % Note: In loop checking, we don't care about the RHS
  _not(V1 = W1 \/ det_mem (dedc_pair T (mp (sign V1 U1) RHS)) LoopIn) /\
  LoopOut = cons (dedc_pair T (mp (sign V1 U1) (sign V2 U2))) LoopIn /\
  Ds = cons (dedc_pair T (mp (sign W1 U1) (sign W2 U2))) (cons (mbsc_pair (mp W1 W2) T (mp V1 V2)) CsL) 
  %/\ printstr "\nRbdsgn 1\n"
;

% Notice that we got U1 U2 , V1 but not V2, We need to unify Y with sign V2 U2
% How to get V2?
% Consider the case when RHS is a variable then substitute Y with sign Y U2
transformation_rule_loop_mbsc_pair (dedc_pair T (mp (sign V1 U1) (var Y))) CsL Ds LoopIn LoopOut (mpsub SubstInL SubstInR) (mpsub SubstInL SubstOutR) Vs Pre NewPre :=
  _distinct(sub_term_list_pair (mp (sign W1 U1) (sign W2 U2)) T) /\
  % Check condition on the LHS - In loop checking, we don't care about the RHS
  _not(V1 = W1 \/ det_mem (dedc_pair T (mp (sign V1 U1) RHS)) LoopIn) /\
  LoopOut = cons (dedc_pair T (mp (sign V1 U1) (sign (var Y) U2))) LoopIn /\
  % (var Y) -> sign (var Y) U2
  SubstR = (cons (sub (var Y) (sign (var Y) U2)) nil) /\
  compose Vs SubstInR SubstR SubstOutR /\
  % This rule is related to the RHS therefore we need to do substitution to both side, CsL and Pre
  cs_apply_list_pair (mpsub nil SubstR) Pre NewPre /\
  cs_apply_list_pair (mpsub nil SubstR) CsL CsLI /\
  Ds = cons (dedc_pair T (mp (sign W1 U1) (sign W2 U2))) (cons (mbsc_pair (mp W1 W2) T (mp V1 (var Y))) CsLI) 
  %/\ printstr "\nRbdsgn 2\n" /\ print_cst_pair_list (cons (dedc_pair T (mp (sign V1 U1) (var Y))) CsL) /\ print_cst_pair_list Ds /\ print_subst_pair (mpsub SubstInL SubstOutR)
.

Define transformation_rule_pair : nat -> list constraint_pair -> list constraint_pair -> prop by
% Ra
transformation_rule_pair 7 Cs Ds :=
  select Cs (mbsc_pair (mp (var X) (var X)) T' V) CsI /\ select CsI (dedc_pair T (mp (var X) (var X))) CsII /\
  _not(T = T') /\ subset T T' /\
  Ds = cons (dedc_pair T V) (cons (mbsc_pair (mp (var X) (var X)) T V) CsI)
  %/\ printstr "\nRa\n"
;
% Rb
transformation_rule_pair 8 Cs Ds :=
  select Cs (mbsc_pair (mp (var X) (var X)) T' V) CsI /\ select CsI (dedc_pair T (mp (var X) (var X))) CsII /\
  _not(T = T') /\ subset T T' /\ _distinct(sub_term_list_pair W T) /\ 
  Ds = cons (dedc_pair T W) (cons (mbsc_pair (mp (var X) (var X)) T W) (cons (mbsc_pair W T' V) CsI))
  %/\ printstr "\nRb\n" /\ print_cst_pair_list Cs /\ print_cst_pair_list Ds
;
% Rc
transformation_rule_pair 9 Cs Ds :=
  select Cs (mbsc_pair (mp (var X) (var X)) T V') CsI /\ select CsI (mbsc_pair (mp (var X) (var X)) T V) CsII /\ select CsII (dedc_pair T (mp (var X) (var X))) CsIII /\
  get_T_var_pair Cs (var X) nil TVar /\ subset T TVar /\
  Ds = cons (mbsc_pair V T V') CsI
  %/\ printstr "\nRc\n"
.

Define separate_pair : list constraint_pair -> list constraint_pair -> list constraint_pair -> prop by
separate_pair nil nil nil ;
separate_pair (cons Cs CsL) Pre Post :=
  separate_pair CsL NewPre NewPost /\
  _if (Cs = dedc_pair T (mp (var X) (var Y)) \/ Cs = mbsc_pair V T U)
    (Pre = cons Cs NewPre /\ Post = NewPost)
    (Pre = NewPre /\ Post = cons Cs NewPost).

% Solved Form
Define cs_solved_form_pair : list constraint_pair -> prop by
cs_solved_form_pair nil ;
cs_solved_form_pair CsL := _not (CsL = nil) /\
  _not (
    member (dedc_pair T (mp U1 U2)) CsL /\
    _not (U1 = var X /\ U2 = var X)
  ) /\
  _not (
    select CsL (mbsc_pair (mp V1 V2) T (mp U1 U2)) CsLI /\
    (
      _not (V1 = var X /\ V2 = var X) \/
      _not (member (dedc_pair T (mp V1 V2)) CsLI) \/
      member (mbsc_pair (mp V1 V2) T' (mp U1' U2')) CsLI
    )
  ).

% Simplication rules for membership constraints
% Note: In a set of constraints in simplified form, each membership constraint is of the form mbsc (var X) T U
Define simplication_rule_pair : list constraint_pair -> list constraint_pair -> list constraint_pair -> subst_pair -> subst_pair -> list tm -> prop by
simplication_rule_pair CsIn nil CsIn SubstIn SubstIn Vs ;

% Sax
simplication_rule_pair Processed (cons (mbsc_pair (mp V1 V2) T (mp U1 U2)) CsL) CsOut SubstIn SubstOut Vs :=
  % Check the apply condition on the left hand side
  _not (V1 = U1 \/ V1 = blind M1 N1 \/ V1 = pr M1 N1) /\
  %printstr "\nSax 1\n" /\ print_cst_pair_list CsL /\ print_subst_pair SubstIn /\
  _if (_cut(select CsL (mbsc_pair (mp V1 V2) T (mp U1 U2)) CsLI))
    (simplication_rule_pair Processed CsL CsOut SubstIn SubstOut Vs)
    (
      _not(V1 = en M1 N1 \/ V1 = aen M1 N1 \/ V1 = sign M1 N1 \/ V1 = mac M1 N1 \/ V1 = pub M1 \/ V1 = hs M1 ) /\ simplication_rule_pair (cons (mbsc_pair (mp V1 V2) T (mp U1 U2)) Processed) CsL CsOut SubstIn SubstOut Vs
    ) ;
simplication_rule_pair Processed (cons (mbsc_pair (mp U1 Y1) T (mp U1 Y2)) CsL) CsOut (mpsub SubstInL SubstInR) SubstOut Vs :=
  unify nil Y1 Y2 Vs SubstR /\
  compose Vs SubstInR SubstR SubstInRI /\
  cs_apply_list_pair (mpsub nil SubstR) Processed NewProcessed /\
  cs_apply_list_pair (mpsub nil SubstR) CsL NewCsL /\
  % Note: We only care about the LHS, therefore the differences in substitution in RHS do not affect the rules
  %printstr "\nSax 2\n" /\ print_cst_pair_list NewCsL /\
  simplication_rule_pair NewProcessed NewCsL CsOut (mpsub SubstInL SubstInRI) SubstOut Vs;

% Sbd
simplication_rule_pair Processed (cons (mbsc_pair (mp (blind U1 V1) (blind U2 V2)) T (mp W1 W2)) CsL) CsOut SubstIn SubstOut Vs :=
  _not (W1 = blind U1 V1 \/ W2 = blind U2 V2) /\
  append Processed (cons (dedc_pair T (mp V1 V2)) (cons (mbsc_pair (mp U1 U2) T (mp W1 W2)) CsL)) CsIn /\
  %printstr "\nSbd\n" /\
  simplication_rule_pair nil CsIn CsOut SubstIn SubstOut Vs ;

% Sbd - Unify
simplication_rule_pair Processed (cons (mbsc_pair (mp U1 U2) T (mp W1 W2)) CsL) CsOut (mpsub SubstInL SubstInR) SubstOut Vs :=
  _not (U1 = W1 \/ U1 = var X) /\
  unify nil U1 W1 Vs SubstL /\ unify nil U2 W2 Vs SubstR /\
  compose Vs SubstInL SubstL SubstInLI /\ compose Vs SubstInR SubstR SubstInRI /\
  append Processed CsL CsLI /\
  cs_apply_list_pair (mpsub SubstL SubstR) CsLI Ds /\
  %printstr "\nSbd-Unify\n" /\
  simplication_rule_pair nil Ds CsOut (mpsub SubstInLI SubstInRI) SubstOut Vs ;
% Sleft
simplication_rule_pair Processed (cons (mbsc_pair (mp (pr U1 V1) (pr U2 V2)) T (mp W1 W2)) CsL) CsOut SubstIn SubstOut Vs :=
  _not (pr U1 V1 = W1 \/ pr U2 V2 = W2) /\
  append Processed (cons (mbsc_pair (mp U1 U2) T (mp W1 W2)) CsL) CsIn /\
  %printstr "\nSleft\n" /\
  simplication_rule_pair nil CsIn CsOut SubstIn SubstOut Vs ;
% Sright
simplication_rule_pair Processed (cons (mbsc_pair (mp (pr U1 V1) (pr U2 V2)) T (mp W1 W2)) CsL) CsOut SubstIn SubstOut Vs :=
  _not (pr U1 V1 = W1 \/ pr U2 V2 = W2) /\
  append Processed (cons (mbsc_pair (mp V1 V2) T (mp W1 W2)) CsL) CsIn /\
  %printstr "\nSright\n" /\
  simplication_rule_pair nil CsIn CsOut SubstIn SubstOut Vs ;
% Rax
simplication_rule_pair Processed (cons (dedc_pair T (mp U1 U2)) CsL) CsOut (mpsub SubstInL SubstInR) SubstOut Vs :=
  (
    (det_mem (mp U1 Y) T /\ unify nil Y U2 Vs SubstR) \/
    (U1 = ct M /\ unify nil (ct M) U2 Vs SubstR)
  ) /\
  compose Vs SubstInR SubstR SubstInRI /\
  cs_apply_list_pair (mpsub nil SubstR) Processed NewProcessed /\
  cs_apply_list_pair (mpsub nil SubstR) CsL NewCsL /\
  % Note: We only care about the LHS, therefore the differences in substitution in RHS do not affect the rules
  %printstr "\nRax\n" /\ print_cst_pair_list NewCsL /\
  simplication_rule_pair NewProcessed NewCsL CsOut (mpsub SubstInL SubstInRI) SubstOut Vs ;
% Special case
simplication_rule_pair Processed (cons (dedc_pair T (mp (var X1) (var Y1))) CsL) CsOut (mpsub SubstInL SubstInR) SubstOut Vs :=
  _not(X1 = Y1) /\ SubstR = cons (sub (var Y1) (var X1)) nil /\
  compose Vs SubstInR SubstR SubstInRI /\
  cs_apply_list_pair (mpsub nil SubstR) Processed NewProcessed /\
  cs_apply_list_pair (mpsub nil SubstR) CsL NewCsL /\
  % Note: We only care about the LHS, therefore the differences in substitution in RHS do not affect the rules
  %printstr "\nRax\n" /\ print_cst_pair_list NewCsL /\
  simplication_rule_pair NewProcessed (cons (dedc_pair T (mp (var X1) (var X1))) NewCsL) CsOut (mpsub SubstInL SubstInRI) SubstOut Vs ;
% Rtriv
simplication_rule_pair Processed (cons (dedc_pair T (mp U1 U2)) CsL) CsOut SubstIn SubstOut Vs :=
  _not (det_mem (mp U1 RHS) T \/ U1 = ct M) /\ _not(U1 = var X /\ _not(U1 = U2)) /\
  append Processed CsL CsIn /\
  _if (_cut(select CsIn (dedc_pair T' (mp U1 U2)) CsLI))
    (
      _if (subset T T')
	(
	  %printstr "\nRtriv\n" /\
	  simplication_rule_pair (cons (dedc_pair T (mp U1 U2)) nil) CsLI CsOut SubstIn SubstOut Vs
	)
	(
	  %printstr "\nRtriv\n" /\
	  simplication_rule_pair Processed CsL CsOut SubstIn SubstOut Vs
	)
    )
    (
      simplication_rule_pair (cons (dedc_pair T (mp U1 U2)) Processed) CsL CsOut SubstIn SubstOut Vs
    ) .
% Sf is not necessary to check
% Need to check Scycle

Define unify_list_pair : list tm -> list thy_pair -> thy_pair -> list sub_pair -> list sub_pair -> prop by 
unify_list_pair Vs (cons (mp X1 X2) L) (mp Y1 Y2) SubstL SubstR := 
  (unify nil X1 Y1 Vs SubstL /\ unify nil X2 Y2 Vs SubstR) \/
  unify_list_pair Vs L (mp Y1 Y2) SubstL SubstR.

%----------------------------------------------------------------------------------------------------------------------%
% UNIFICATION RULES
%----------------------------------------------------------------------------------------------------------------------%

Define unify_constraint_pair : list tm -> list constraint_pair -> constraint_pair -> list constraint_pair -> list constraint_pair -> subst_pair -> subst_pair -> prop by
unify_constraint_pair Vs Pre (dedc_pair T U) Post Ds (mpsub SubstInL SubstInR) (mpsub SubstOutL SubstOutR) :=
  U = mp U1 U2 /\ _not (U1 = sign M1 N1) /\ unify_list_pair Vs T U SubstL SubstR /\
  compose Vs SubstInL SubstL SubstOutL /\ compose Vs SubstInR SubstR SubstOutR /\
  append Pre Post CsL /\
  cs_apply_list_pair (mpsub SubstL SubstR) CsL Ds
  %/\ printstr "\nUnification Rule 1\n"
;
unify_constraint_pair Vs Pre (dedc_pair T (mp V1 V2)) Post Ds (mpsub SubstInL SubstInR) (mpsub SubstOutL SubstOutR) := 
  _cut(sub_term_list_pair (mp (aen V1 (var X1)) (aen V2 (var X2))) T) /\
  SubstL = (cons (sub (var X1) (pub (var X1))) nil) /\ SubstR = (cons (sub (var X2) (pub (var X2))) nil) /\
  compose Vs SubstInL SubstL SubstOutL /\ compose Vs SubstInR SubstR SubstOutR /\
  append Pre (cons (dedc_pair T V) Post) CsL /\
  cs_apply_list_pair (mpsub SubstL SubstR) CsL Ds
  %/\ printstr "\nUnification Rule 2\n"
.

%----------------------------------------------------------------------------------------------------------------------%
% CHECK Scycle
% Construct the increasing set of variables until we got two similar set
% If the final set equals to set of all the variables, we got the variable cycle
% Cannot initialize the first set (Cannot assure all vertices are connected)
%----------------------------------------------------------------------------------------------------------------------%

%Define separate_mbsc_pair : list constraint_pair -> list constraint_pair -> prop by
%separate_mbsc_pair nil nil;
%separate_mbsc_pair (cons (mbsc_pair (mp (var X) RHS) T U) CsLIn) (cons (mbsc_pair (mp (var X) RHS) T U) CsLOut) := separate_mbsc_pair CsLIn CsLOut ;
%separate_mbsc_pair (cons (dedc_pair T U) CsLIn) CsLOut := separate_mbsc_pair CsLIn CsLOut .

%Define merge : list A -> list A -> list A -> prop by
%merge nil L L;
%merge (cons X L1) L2 L3 := merge L1 L2 L4 /\ insert X L4 L3.

%Define find_all_variable : list constraint_pair -> list tm -> prop by
%find_all_variable nil nil ;
%find_all_variable (cons (mbsc_pair (mp (var X) RHS) T U) CsLIn) VarOut :=
%  find_all_variable CsLIn VarOutI /\
%  split_thy T S1 S2 /\
%  get_var_list_tm S1 nil TVar /\
%  insert (var X) TVar TVarI /\
%  merge TVarI VarOutI VarOut.

%Define construct_variable_list : list constraint_pair -> list tm -> list tm -> prop by
%construct_variable_list nil VarIn VarIn ;
%construct_variable_list (cons (mbsc_pair (mp (var X) RHS) T U) CsLIn) VarIn VarOut :=
%  split_thy T S1 S2 /\
%  get_var_list_tm S1 nil TVar /\
%  _if (det_mem (var X) VarIn) (
%    construct_variable_list CsLIn VarIn VarOutI /\
%    merge TVar VarIn VarOut
%  )
%  (construct_variable_list CsLIn VarIn VarOut).
  
%Define find_variable_list : list constraint_pair -> list tm -> list tm -> prop by
%find_variable_list CsL VarIn VarOut :=
%  construct_variable_list CsL VarIn VarInI /\ print_list VarIn /\ print_list VarInI /\
%  _if (VarInI = VarIn) (VarOut = VarIn)
%  (find_variable_list CsL VarInI VarOut).

%Define check_cycle : list constraint_pair -> prop by
%check_cycle CsLIn :=
%  separate_mbsc_pair CsLIn CsL /\
%  find_all_variable CsL AllVars /\
%  _if (AllVars = nil) (true)
%  (
%    find_variable_list CsL nil VarOut /\
%    _not(subset AllVars VarOut)
%  ).

Define check_cycle : list constraint_pair -> prop by  
check_cycle CsL := 
  _not (member (mbsc_pair (mp (var X) RHS1) T (mp VX RHS2) ) CsL /\ get_var VX nil VarList /\ member (var X) VarList).

%----------------------------------------------------------------------------------------------------------------------%
% MAIN FUNCTION
%----------------------------------------------------------------------------------------------------------------------%
% Important note: Substitution might need to applied to LoopMbsc and LoopDedc
Define cs_solve_pair : list tm -> list constraint_pair -> list constraint_pair -> subst_pair -> subst_pair ->
list constraint_pair -> list constraint_pair -> list constraint_pair -> prop by
cs_solve_pair Vs Pre Post SubstInX SubstOut LoopDedcIn LoopMbscIn SolvedForm :=
  append Pre Post PreCsL /\
  check_cycle PreCsL /\  
  %printstr "\nBefore Simplification: " /\ print_cst_pair_list PreCsL /\ print_subst_pair SubstInX /\
  simplication_rule_pair nil PreCsL CsL SubstInX SubstIn Vs /\
  %printstr "\nAfter Simplification: " /\ print_cst_pair_list CsL /\ print_subst_pair SubstIn /\
  _if (cs_solved_form_pair CsL) ( SubstOut = SubstIn /\ SolvedForm = CsL)
    (
      separate_pair CsL PreI NewPost /\
      _if (NewPost = nil) (transformation_rule_pair TR CsL Ds /\ cs_solve_pair Vs nil Ds SubstIn SubstOut LoopDedcIn LoopMbscIn SolvedForm)
      (
	NewPost = cons Cs PostII /\
	(
	  (unify_constraint_pair Vs PreI Cs PostII Ds SubstIn NewSubst /\ NewPre = nil /\ LoopDedcOut = LoopDedcIn /\ LoopMbscOut = LoopMbscIn /\ NewVs = Vs) \/
	  (transformation_rule_loop_dedc_pair Cs PostII Ds LoopDedcIn LoopDedcOut SubstIn NewSubst Vs PreI NewPre NewVs /\ LoopMbscOut = LoopMbscIn) \/
	  (transformation_rule_loop_mbsc_pair Cs PostII Ds LoopMbscIn LoopMbscOut SubstIn NewSubst Vs PreI NewPre /\ LoopDedcOut = LoopDedcIn /\ NewVs = Vs)
	) /\
	cs_solve_pair NewVs NewPre Ds NewSubst SubstOut LoopDedcOut LoopMbscOut SolvedForm
      )
    ) .

% Two constraint system pair share the same variable list
Define cs_solve_constraints_pair : list tm -> list constraint_pair -> subst_pair -> list constraint_pair -> prop by
cs_solve_constraints_pair Vs CsL Subst SolvedForm :=
  id_subst Vs IdSubst /\
  cs_solve_pair Vs nil CsL (mpsub IdSubst IdSubst) Subst nil nil SolvedForm.
